---
// src/components/Analytics.astro
// Core Web Vitals tracking only
// Listens for Astro Page Load event
// Updated 250907 17:05 - Added debug toggle, clean production mode

const siteId = Astro.site ? new URL(Astro.site).hostname : 'localhost';
---

<script define:vars={{ siteId }} is:inline>
	(function () {
		// Prevent multiple initializations during view transitions
		if (window.__astro_analytics_initialized) {
			return;
		}
		window.__astro_analytics_initialized = true;

		// Debug toggle - set to false for production
		const DEBUG = false;

		const log = (...args) => DEBUG && console.log(...args);
		const warn = (...args) => DEBUG && console.warn(...args);
		const logError = (...args) => DEBUG && console.error(...args);

		log("ðŸš€ Astro-only Analytics loaded");

		if (
			location.hostname === "localhost" ||
			location.hostname === "127.0.0.1"
		) {
			log("ðŸš§ Disabled in development");
			return;
		}

		// Track active observers so we can disconnect them between navigations
		let activeObservers = [];

		function disconnectObservers() {
			activeObservers.forEach((obs) => obs.disconnect());
			activeObservers = [];
		}

		function trackPageCWV() {
			// Disconnect any observers from the previous page
			disconnectObservers();

			// Simple session management - one per browser session
			let sessionId = sessionStorage.getItem("astro_cwv_session");
			if (!sessionId) {
				sessionId =
					"cwv_" +
					Date.now() +
					"_" +
					Math.random().toString(36).substring(2, 11);
				sessionStorage.setItem("astro_cwv_session", sessionId);
				log("ðŸ†• New session:", sessionId);
			}

			const currentPath = location.pathname;

			// Per-page time-based deduplication (60 seconds)
			const now = Date.now();
			const lastSentKey = `cwv_sent_${currentPath}`;
			const lastSent = parseInt(sessionStorage.getItem(lastSentKey) || "0");
			const timeSinceLastSent = now - lastSent;
			const cooldown = 60000; // 60s

			if (timeSinceLastSent < cooldown) {
				log(
					`â­ï¸ Skip ${currentPath} - sent ${Math.round(timeSinceLastSent / 1000)}s ago`,
				);
				return;
			}

			// Browser detection
			const parseBrowser = (ua) => {
				if (!ua) return "Unknown";
				const lower = ua.toLowerCase();
				if (lower.includes("safari/") && !lower.includes("chrome")) {
					const version = ua.match(/version\/(\d+)/i);
					return `Safari ${version ? version[1] : ""}`;
				} else if (lower.includes("chrome/") && !lower.includes("edg")) {
					const version = ua.match(/chrome\/(\d+)/i);
					return `Chrome ${version ? version[1] : ""}`;
				} else if (lower.includes("firefox/")) {
					const version = ua.match(/firefox\/(\d+)/i);
					return `Firefox ${version ? version[1] : ""}`;
				}
				return "Other";
			};

			const browser = parseBrowser(navigator.userAgent);
			log("ðŸ” Browser:", browser, "| Path:", currentPath);

			const metrics = {
				session_id: sessionId,
				site_id: siteId,
				url: location.href,
				path: currentPath,
				user_agent: navigator.userAgent,
				browser: browser,
				screen_width: window.screen.width,
				screen_height: window.screen.height,
				lcp: null,
				cls: 0,
				fcp: null,
				ttfb: null,
				inp: null,
			};

			log("ðŸ“Š Starting fresh CWV capture");

			// TTFB - only meaningful for actual navigation, not view transitions
			const navEntry = performance.getEntriesByType("navigation")[0];
			if (navEntry && navEntry.responseStart) {
				metrics.ttfb = navEntry.responseStart;
				log("âœ… TTFB:", metrics.ttfb);
			}

			// For Astro view transitions, always use buffered observers
			log("ðŸŽ¯ Using buffered observers (Astro view transitions)");

			// LCP - always buffered for Astro
			try {
				const lcpObs = new PerformanceObserver((list) => {
					const entries = list.getEntries();
					log("ðŸ” LCP Observer fired - entries:", entries.length);
					const lastEntry = entries[entries.length - 1];
					if (lastEntry) {
						metrics.lcp =
							lastEntry.renderTime || lastEntry.loadTime || lastEntry.startTime;
						log("âœ… LCP set to:", metrics.lcp);
					}
				});
				lcpObs.observe({ type: "largest-contentful-paint", buffered: true });
				activeObservers.push(lcpObs);
			} catch (e) {
				logError("âŒ LCP observer failed:", e.message);
			}

			// FCP - always buffered for Astro
			try {
				const fcpObs = new PerformanceObserver((list) => {
					for (const entry of list.getEntries()) {
						if (entry.name === "first-contentful-paint") {
							metrics.fcp = entry.startTime;
							log("âœ… FCP:", metrics.fcp);
						}
					}
				});
				fcpObs.observe({ type: "paint", buffered: true });
				activeObservers.push(fcpObs);
			} catch (e) {
				logError("âŒ FCP observer failed:", e.message);
			}

			// CLS - use buffered for cumulative score
			try {
				const clsObs = new PerformanceObserver((list) => {
					for (const entry of list.getEntries()) {
						if (!entry.hadRecentInput && entry.value !== undefined) {
							metrics.cls += entry.value;
							log("âœ… CLS delta:", entry.value, "| Total:", metrics.cls);
						}
					}
				});
				clsObs.observe({ type: "layout-shift", buffered: true });
				activeObservers.push(clsObs);
			} catch (e) {
				logError("âŒ CLS observer failed:", e.message);
			}

			// INP - Interaction to Next Paint
			try {
				const inpObs = new PerformanceObserver((list) => {
					let maxDelay = 0;
					for (const entry of list.getEntries()) {
						if (entry.interactionId && entry.duration) {
							maxDelay = Math.max(maxDelay, entry.duration);
						}
					}
					if (maxDelay > 0) {
						metrics.inp = maxDelay;
						log("âœ… INP set to:", metrics.inp, "ms");
					}
				});
				inpObs.observe({ type: "event", buffered: true, durationThreshold: 0 });
				activeObservers.push(inpObs);
			} catch (e) {
				logError("âŒ INP observer failed:", e.message);
			}

			// Send metrics function
			let sent = false;
			function sendMetrics() {
				if (sent) return;
				sent = true;

				// Disconnect observers before sending final values
				disconnectObservers();

				log("ðŸ“¤ Sending:", {
					path: metrics.path,
					browser: metrics.browser,
					lcp: metrics.lcp,
					fcp: metrics.fcp,
					cls: metrics.cls,
					ttfb: metrics.ttfb,
					inp: metrics.inp,
				});

				const blob = new Blob([JSON.stringify(metrics)], {
					type: "application/json",
				});

				if (navigator.sendBeacon) {
					navigator.sendBeacon("/.netlify/functions/pandalytics", blob);
					log("ðŸ“¡ Sent via beacon");
				} else {
					fetch("/.netlify/functions/pandalytics", {
						method: "POST",
						body: JSON.stringify(metrics),
						headers: { "Content-Type": "application/json" },
						keepalive: true,
					}).catch(() => {});
					log("ðŸ“¡ Sent via fetch");
				}

				sessionStorage.setItem(lastSentKey, now.toString());
				log("âœ… Marked sent:", new Date().toLocaleTimeString());
			}

			// Send on page hide (covers tab close, navigation away, tab switch)
			document.addEventListener("visibilitychange", function onHide() {
				if (document.visibilityState === "hidden") {
					sendMetrics();
					document.removeEventListener("visibilitychange", onHide);
				}
			});

			// Fallback: send after 5s if page is still visible
			setTimeout(() => {
				sendMetrics();
			}, 5000);
		}

		// ONLY listen to astro:page-load (fires for all Astro navigation)
		document.addEventListener("astro:page-load", () => {
			log("ðŸŽ¯ astro:page-load fired");
			trackPageCWV();
		});

		log("âœ… Pandalytics ready");
	})();
</script>
